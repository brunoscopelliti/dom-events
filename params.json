{"name":"Dom-events","tagline":"A JavaScript event handler micro library.","body":"A JavaScript delegation event micro library.\r\n\r\n## about\r\n\r\ndom-events (dom-events-delegation on npm) is written as an ECMAScript2015 module, and uses ECMAScript2015 features such destructuring, default values, weak map; it's possible to use in the browser today through the combo jspm package loader and babeljs.\r\n\r\nWhen the module is transpiled (with some polyfill installed such as `Array.from`, `Symbol`, `Weakmap`), it proved to work until IE10 (never tested with IE9). \r\n\r\nIn case you need another module format there are several projects which can do automatically the conversion.\r\n\r\n## install\r\n\r\n```\r\nnpm install --save dom-events-delegation\r\n```\r\n\r\n## CI report\r\n\r\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/brunoscopelliti.svg)](https://saucelabs.com/u/brunoscopelliti)\r\n\r\n**known issues**\r\n\r\n* `[DEL4]` fails on Firefox, cause https://bugzilla.mozilla.org/show_bug.cgi?id=218093 . Same issue affects jQuery too.\r\n\r\n* CI skips tests, about focus/blur events, from `[FRM5]` to `[FRM8]` cause when launched headless they fail on Firefox... however they pass when launched in the browser.\r\n\r\n## api and usages\r\n\r\nFor the examples in the current section I consider the following DOM tree:\r\n\r\n```\r\n<section id=\"main\">\r\n <h1>Choose a pillow:</h1>\r\n <ul>\r\n  <li>\r\n   <input id=\"opt1\" type=\"radio\" name=\"colour\" value=\"red\"/>\r\n   <label for=\"opt1\">red</label>\r\n  </li>\r\n  <li>\r\n   <input id=\"opt2\" type=\"radio\" name=\"colour\" value=\"blue\"/>\r\n   <label for=\"opt2\">blue</label>\r\n  </li>  \r\n </ul>\r\n <button id=\"btn\">Pick the pillow</button>\r\n</section>\r\n```\r\n\r\n**Events.on**\r\n\r\n```\r\non: function on(htmlElements, type, [delegator, ] handler);\r\n \r\n - {HTMLElement|HTMLCollection|NodeList} htmlElements: html elements for which the event listener will be set\r\n - {String} type: the name of the event\r\n - {String} [delegator]: the selector of the elements which should react on the event\r\n - {Function} handler: the function that should be called when the event is triggered\r\n```\r\n\r\nAdd an event listener on the DOM elements passed as parameter.\r\n\r\nIf we want to add a listener on the button, we could simply write something like:\r\n\r\n```\r\nvar btn = document.getElementById(\"btn\");\r\n// not really need this step (http://www.2ality.com/2012/08/ids-are-global.html), but for clarity sake.\r\n\r\nEvents.on(btn, 'click', function() { /* do your stuff here */ });\r\n```\r\n\r\nOr using event delegation:\r\n\r\n```\r\nvar main = document.getElementById(\"main\");\r\nEvents.on(main, 'click', '#btn', function() { /* do your stuff here */ });\r\n```\r\n\r\nOf course this is more useful in case you want to attach the same handler on several targets.\r\n\r\n\r\n**Events.off**\r\n\r\n```\r\noff: function off(htmlElements, [type, ] [delegator, ] [handler] );\r\n \r\n - {HTMLElement|HTMLCollection|NodeList} htmlElements: html elements for which the event listener will be removed\r\n - {String} [type]: the name of the event\r\n - {String} [delegator]\r\n - {Function} [handler]\r\n```\r\n\r\nRemove the event listeners which match the parameters from the DOM elements passed as first argument.\r\n\r\nSo if you want to remove the previous listeners:\r\n\r\n```\r\nEvents.off(btn); // remove all the listener attached on btn\r\nEvents.off(btn, 'click'); // remove all the click listener attached on btn\r\n// ...\r\n// it's even possible to remove only the listeners with a specific delegator, or handler, or both.\r\n```\r\n\r\n\r\n**Events.fire**\r\n\r\n```\r\nfire: function fire(htmlElements, type, ...data)\r\n \r\n - {HTMLElement|HTMLCollection|NodeList} htmlElements: html elements for which simulate the event\r\n - {String} type: the name of the event\r\n - {Any} [data]: additional arguments for the event handler\r\n```\r\n\r\nSimulate the triggering of the event `type` on the elements `htmlElements`.\r\nIt executes the handlers attached on `htmlElements`, and simulate the bubbling of the event, on their parents.\r\n\r\nLet's try to simulate the click on the button.\r\n\r\n```\r\nEvents.fire(btn, 'click'); \r\n\r\n// ... and we can also pass additional custom data, which will be available as arguments in the event handler function.\r\n\r\nEvents.on(btn, 'click', function(evt, ...args) {\r\n console.log(args); // ['foo', 'bar']\r\n});\r\n\r\nEvents.fire(btn, 'click', 'foo', 'bar');\r\n```\r\n\r\n**Events.debug**\r\n\r\n```\r\ndebug: function debug(htmlElement, type = \"\")\r\n \r\n - {HTMLElement} htmlElement: the html element for which to get events' information\r\n - {String} [type]: the name of the event\r\n```\r\n\r\nGet the list of the event listeners registered on a particular html element.\r\nIf the event type is not specified it returns all the events set on that particular dom element.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}